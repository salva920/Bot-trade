#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üéØ BACKTEST DE DIRECCI√ìN - ESTRATEGIA BREAKOUT INTRADIARIO
=========================================================
Analiza solo la direcci√≥n (BUY/SELL) del bot vs direcci√≥n real del precio
Periodo: 2-3 meses del mercado de Nueva York (8:00-17:00 EST)
Objetivo: Calcular porcentaje de acierto en direcci√≥n
"""

from broker.mt5_connector import conectar_mt5, obtener_datos
from strategy.breakout_intradiario import detectar_breakout_eurusd_backtest, calcular_indicadores_breakout
from utils.time_utils import es_horario_ny
import MetaTrader5 as mt5
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import pytz


def backtest_direccion_ny(periodo_meses=3):
    """
    Backtest de direcci√≥n durante periodo espec√≠fico del mercado NY
    """
    print(f"üéØ BACKTEST DE DIRECCI√ìN - MERCADO NY")
    print(f"üìÖ Periodo: {periodo_meses} meses")
    print(f"‚è∞ Horario: 8:00-17:00 EST (Mercado NY)")
    print(f"üéØ Objetivo: Porcentaje de acierto en direcci√≥n")
    print("="*60)
    
    if not conectar_mt5():
        print("‚ùå Error conectando a MT5")
        return
    
    # Calcular fechas del periodo
    fecha_fin = datetime.now()
    fecha_inicio = fecha_fin - timedelta(days=periodo_meses * 30)
    
    print(f"üìÖ Periodo analizado: {fecha_inicio.strftime('%Y-%m-%d')} a {fecha_fin.strftime('%Y-%m-%d')}")
    
    # Obtener datos hist√≥ricos para el periodo
    print("üì• Obteniendo datos hist√≥ricos...")
    
    # Convertir fechas a timestamp para MT5
    from_date = int(fecha_inicio.timestamp())
    to_date = int(fecha_fin.timestamp())
    
    # Obtener datos M5 (timeframe principal para an√°lisis)
    rates = mt5.copy_rates_range("EURUSD", mt5.TIMEFRAME_M5, from_date, to_date)
    
    if rates is None or len(rates) == 0:
        print("‚ùå No se pudieron obtener datos hist√≥ricos")
        return
    
    # Convertir a DataFrame
    df = pd.DataFrame(rates)
    df['time'] = pd.to_datetime(df['time'], unit='s')
    
    print(f"‚úÖ Datos obtenidos: {len(df)} velas M5")
    print(f"üìÖ Rango: {df['time'].min()} a {df['time'].max()}")
    
    # Filtrar solo horario NY (8:00-17:00 EST)
    print("üîç Filtrando horario NY...")
    df_ny = filtrar_horario_ny(df)
    print(f"‚úÖ Velas en horario NY: {len(df_ny)}")
    
    # Calcular indicadores
    print("üîß Calculando indicadores...")
    df_ny = calcular_indicadores_breakout(df_ny.copy())
    
    # An√°lisis de direcci√≥n
    resultados = analizar_direccion_bot(df_ny)
    
    # Mostrar resultados
    mostrar_resultados_direccion(resultados, df_ny)
    
    return resultados


def filtrar_horario_ny(df):
    """
    Filtra datos para incluir solo horario NY (8:00-17:00 EST)
    """
    # Convertir a zona horaria EST
    est = pytz.timezone('US/Eastern')
    
    # Aplicar zona horaria y filtrar
    df_ny = df.copy()
    df_ny['time_est'] = df_ny['time'].dt.tz_localize('UTC').dt.tz_convert(est)
    df_ny['hora_est'] = df_ny['time_est'].dt.hour
    
    # Filtrar horario NY (8:00-17:00 EST)
    df_ny = df_ny[(df_ny['hora_est'] >= 8) & (df_ny['hora_est'] < 17)]
    
    return df_ny


def analizar_direccion_bot(df_ny):
    """
    Analiza la direcci√≥n del bot vs direcci√≥n real del precio
    """
    print("üîç Analizando direcci√≥n del bot...")
    
    resultados = {
        'total_se√±ales': 0,
        'aciertos_direccion': 0,
        'errores_direccion': 0,
        'se√±ales_buy': 0,
        'se√±ales_sell': 0,
        'aciertos_buy': 0,
        'aciertos_sell': 0,
        'detalles': []
    }
    
    # Analizar cada vela en horario NY
    for i in range(100, len(df_ny) - 10):  # Dejar espacio para validaci√≥n futura
        try:
            # Crear subconjunto de datos hasta el punto actual
            sub_df = df_ny.iloc[:i+1].copy()
            
            # Simular detecci√≥n de se√±al del bot
            se√±al = detectar_se√±al_direccion(sub_df)
            
            if se√±al:
                tipo_se√±al, precio_entrada, tiempo_se√±al = se√±al
                resultados['total_se√±ales'] += 1
                
                if tipo_se√±al == 'BUY':
                    resultados['se√±ales_buy'] += 1
                else:
                    resultados['se√±ales_sell'] += 1
                
                # Verificar direcci√≥n real del precio en las siguientes velas
                acierto = verificar_direccion_real(df_ny, i, tipo_se√±al, precio_entrada)
                
                if acierto:
                    resultados['aciertos_direccion'] += 1
                    if tipo_se√±al == 'BUY':
                        resultados['aciertos_buy'] += 1
                    else:
                        resultados['aciertos_sell'] += 1
                else:
                    resultados['errores_direccion'] += 1
                
                # Guardar detalle
                resultados['detalles'].append({
                    'tiempo': tiempo_se√±al,
                    'tipo': tipo_se√±al,
                    'precio': precio_entrada,
                    'acierto': acierto
                })
                
                # Mostrar progreso cada 50 se√±ales
                if resultados['total_se√±ales'] % 50 == 0:
                    print(f"üìä Progreso: {resultados['total_se√±ales']} se√±ales analizadas")
        
        except Exception as e:
            continue
    
    return resultados


def detectar_se√±al_direccion(df):
    """
    Detecta se√±al de direcci√≥n usando la estrategia del bot
    """
    if len(df) < 50:
        return None
    
    # Calcular indicadores
    df = calcular_indicadores_breakout(df.copy())
    
    # Detectar tendencia intradiaria (usando M15 equivalente)
    tendencia = detectar_tendencia_simplificada(df)
    
    if tendencia == 'neutral':
        return None
    
    # Validar condiciones de breakout
    if validar_breakout_direccion(df, tendencia):
        precio_entrada = df['close'].iloc[-1]
        tiempo_se√±al = df['time'].iloc[-1]
        
        if tendencia == 'alcista':
            return ('BUY', precio_entrada, tiempo_se√±al)
        else:
            return ('SELL', precio_entrada, tiempo_se√±al)
    
    return None


def detectar_tendencia_simplificada(df):
    """
    Detecta tendencia usando EMAs
    """
    if len(df) < 20:
        return 'neutral'
    
    # Calcular EMAs
    ema_rapida = df['close'].ewm(span=20, adjust=False).mean()
    ema_lenta = df['close'].ewm(span=50, adjust=False).mean()
    
    ultima_ema_rapida = ema_rapida.iloc[-1]
    ultima_ema_lenta = ema_lenta.iloc[-1]
    
    if ultima_ema_rapida > ultima_ema_lenta:
        return 'alcista'
    elif ultima_ema_rapida < ultima_ema_lenta:
        return 'bajista'
    else:
        return 'neutral'


def validar_breakout_direccion(df, tendencia):
    """
    Valida condiciones de breakout para direcci√≥n
    """
    if len(df) < 20:
        return False
    
    ultima = df.iloc[-1]
    anterior = df.iloc[-2]
    
    # Condiciones optimizadas de breakout
    if tendencia == 'alcista':
        return (
            ultima['close'] > ultima['open'] and                    # Vela alcista
            ultima['close'] > anterior['close'] and                # Precio sube
            ultima['ADX'] >= 12 and                                # ADX optimizado
            ultima['Vol_Relativo'] >= 0.5 and                      # Volumen optimizado
            ultima['RSI'] <= 45 and                                # RSI optimizado
            ultima['Pendiente'] > 0.0001                           # Pendiente optimizada
        )
    
    elif tendencia == 'bajista':
        return (
            ultima['close'] < ultima['open'] and                    # Vela bajista
            ultima['close'] < anterior['close'] and                # Precio baja
            ultima['ADX'] >= 12 and                                # ADX optimizado
            ultima['Vol_Relativo'] >= 0.5 and                      # Volumen optimizado
            ultima['RSI'] >= 55 and                                # RSI optimizado
            ultima['Pendiente'] < -0.0001                          # Pendiente optimizada
        )
    
    return False


def verificar_direccion_real(df, indice_se√±al, tipo_se√±al, precio_entrada):
    """
    Verifica si la direcci√≥n del bot fue correcta
    """
    # Analizar las siguientes 10 velas para determinar direcci√≥n real
    velas_futuras = 10
    if indice_se√±al + velas_futuras >= len(df):
        return False
    
    # Obtener precios futuros
    precios_futuros = df.iloc[indice_se√±al+1:indice_se√±al+velas_futuras+1]['close'].values
    
    # Calcular direcci√≥n real
    precio_max = max(precios_futuros)
    precio_min = min(precios_futuros)
    precio_final = precios_futuros[-1]
    
    if tipo_se√±al == 'BUY':
        # Para BUY: el precio debe subir significativamente
        movimiento_positivo = precio_final - precio_entrada
        movimiento_total = precio_max - precio_entrada
        
        # Considerar acierto si:
        # 1. El precio final es mayor al de entrada, O
        # 2. El precio lleg√≥ a subir al menos 5 pips
        return (movimiento_positivo > 0) or (movimiento_total > 0.0005)
    
    else:  # SELL
        # Para SELL: el precio debe bajar significativamente
        movimiento_negativo = precio_entrada - precio_final
        movimiento_total = precio_entrada - precio_min
        
        # Considerar acierto si:
        # 1. El precio final es menor al de entrada, O
        # 2. El precio lleg√≥ a bajar al menos 5 pips
        return (movimiento_negativo > 0) or (movimiento_total > 0.0005)


def mostrar_resultados_direccion(resultados, df_ny):
    """
    Muestra resultados detallados del an√°lisis de direcci√≥n
    """
    print("\n" + "="*60)
    print("üìä RESULTADOS DEL BACKTEST DE DIRECCI√ìN")
    print("="*60)
    
    if resultados['total_se√±ales'] == 0:
        print("‚ùå No se detectaron se√±ales durante el periodo")
        return
    
    # Estad√≠sticas generales
    total_se√±ales = resultados['total_se√±ales']
    aciertos = resultados['aciertos_direccion']
    errores = resultados['errores_direccion']
    
    porcentaje_acierto = (aciertos / total_se√±ales) * 100
    
    print(f"üìä ESTAD√çSTICAS GENERALES:")
    print(f"   Total se√±ales: {total_se√±ales}")
    print(f"   Aciertos en direcci√≥n: {aciertos}")
    print(f"   Errores en direcci√≥n: {errores}")
    print(f"   Porcentaje de acierto: {porcentaje_acierto:.1f}%")
    
    # An√°lisis por tipo de se√±al
    print(f"\nüìà AN√ÅLISIS POR TIPO DE SE√ëAL:")
    
    if resultados['se√±ales_buy'] > 0:
        acierto_buy = (resultados['aciertos_buy'] / resultados['se√±ales_buy']) * 100
        print(f"   SE√ëALES BUY:")
        print(f"     - Total: {resultados['se√±ales_buy']}")
        print(f"     - Aciertos: {resultados['aciertos_buy']}")
        print(f"     - Porcentaje acierto: {acierto_buy:.1f}%")
    
    if resultados['se√±ales_sell'] > 0:
        acierto_sell = (resultados['aciertos_sell'] / resultados['se√±ales_sell']) * 100
        print(f"   SE√ëALES SELL:")
        print(f"     - Total: {resultados['se√±ales_sell']}")
        print(f"     - Aciertos: {resultados['aciertos_sell']}")
        print(f"     - Porcentaje acierto: {acierto_sell:.1f}%")
    
    # An√°lisis temporal
    print(f"\n‚è∞ AN√ÅLISIS TEMPORAL:")
    print(f"   Periodo analizado: {df_ny['time'].min()} a {df_ny['time'].max()}")
    print(f"   Velas en horario NY: {len(df_ny)}")
    print(f"   Promedio se√±ales por d√≠a: {total_se√±ales / ((df_ny['time'].max() - df_ny['time'].min()).days):.1f}")
    
    # Evaluaci√≥n del rendimiento
    print(f"\nüéØ EVALUACI√ìN DEL RENDIMIENTO:")
    if porcentaje_acierto >= 70:
        print(f"   üü¢ EXCELENTE: {porcentaje_acierto:.1f}% de acierto")
    elif porcentaje_acierto >= 60:
        print(f"   üü° BUENO: {porcentaje_acierto:.1f}% de acierto")
    elif porcentaje_acierto >= 50:
        print(f"   üü† ACEPTABLE: {porcentaje_acierto:.1f}% de acierto")
    else:
        print(f"   üî¥ MEJORABLE: {porcentaje_acierto:.1f}% de acierto")
    
    # Recomendaciones
    print(f"\nüí° RECOMENDACIONES:")
    if porcentaje_acierto < 60:
        print(f"   - Considerar ajustar filtros para mejorar precisi√≥n")
        print(f"   - Analizar periodos de mayor volatilidad")
        print(f"   - Revisar condiciones de entrada")
    else:
        print(f"   - El bot muestra buena precisi√≥n en direcci√≥n")
        print(f"   - Considerar implementar gesti√≥n de riesgo")
        print(f"   - Analizar periodos espec√≠ficos de mayor acierto")
    
    print("\n‚úÖ Backtest de direcci√≥n completado")


if __name__ == "__main__":
    print("üéØ INICIANDO BACKTEST DE DIRECCI√ìN - MERCADO NY")
    print("="*70)
    
    # Ejecutar backtest de 3 meses
    try:
        resultados = backtest_direccion_ny(periodo_meses=3)
        print(f"\nüéØ Backtest completado exitosamente")
    except Exception as e:
        print(f"‚ùå Error en backtest: {e}")
